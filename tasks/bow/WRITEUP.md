# Арбалеты Сибири: Write-up

<p align="center"><img alt="Скринкаст, типа" src="https://k60.in/arb.gif"></p>

«Арбалеты Сибири» — это реалистичный (в первом приближении) симулятор падения стрел, выпущенных их арбалета, написанный                 на профессиональном языке программирования C.

Разобраться с его интерфейсом довольно легко: нащёлкал четыре параметра на удачу — оно и полетело там куда-то. Осталось разобраться со всем остальным. Прямо как вы и хотели:
![Больше реверса!](https://k60.in/more-reverse.png)


### С чего начать

Есть много способов преуспеть в этом деле. Например, воспользоваться анализатором [Гидры](https://ghidra-sre.org/), который умеет превращать бинари в псевдокод. Посмотрим на `main`:  
![main](https://k60.in/dmain.png)

Видно как инициализируется графика, каким-то методом отмеряются четыре параметра, и один раз что-то там, видимо, летит по этим параметрам. Чтобы стало понятнее, пробегитесь по всему коду, который нагенерила Гидра, уделяя особое внимание функциям `binput`, `simulate_hit` и `update_arrow`, потому что они расположены в стратегических местах.

Цель: подобрать значения параметров, при которых стрела летит в Сибирь, а нам достаётся флаг.


### binput
Здесь отрисовываются и считываются те самые бегунки. Алгоритм довольно тупой: в длинную строку из пробелов (выглядит как `0x20...`) подставляется символ `>` или `<`, слушается клавиатура, возвращается текущее значение.

Нам интересен диапазон этих значений, потому что он позволит хотя бы представить себе пространство перебора:
```C
while ((int)local_50 < 0x50) // по-русски — 80
{
    /* ... */
    local_20 = 0x20; // по-русски — 40
    if ((int)local_50 < 0x28)
    {
        uVar3 = 0x3e;
        local_4c = local_50;
        // будет возвращено что-то от 0 до 40
    }
    else
    {
        local_4c = 0x50 - local_50;
        // диапазон выйдет тот же
        uVar3 = 0x3c;
    }
    /* ... */
}
```
Выходит, вариантов всего ![40^4 = 2560000](https://latex.codecogs.com/gif.latex?%5Csmall%2040%5E%7B4%7D%20%3D%202%5Cthinspace560%5Cthinspace000), подумаешь.


### simulate_hit
Здесь четыре набежавших параметра подвергаются какой-то математике. Нам везёт, потому что если поиграться с параметрами анализатора (короче говоря, отметить *все* галочки), получится сравнительно понятый и почти рабочий код.

Фукнции `sin`, `cos` и `exp` есть в библиотеке `math.h`, функций `slw_cmp` и `slw_equ` в ней нет, но из названий следует, что они отвечают за сравнение чисел. Всё остальное кажется довольно тривиальным. Читаем дальше и видим проверку на попадание в Сибирь:
![simulate_hit](https://k60.in/slw_equ.png)  

Догадаться можно по косвенным признакам: здесь сравниваются три подсчитанные штуки с тремя константами — ничего такого больше нигде нет.

Всё, можно писать брутилку. Она набрутит вам единственную верную четвёрку чисел:
```
[!] Got hit with 23 40 0 40
[!] Target is at 1337.028465 64.440931 606.99822
```

### update_arrow
Ничего интересного. Даже флаг не печатается. Эта функция отрисовывает полёт стрелы выше или ниже цели (`simulate_hit` возвращает сюда ровно поэтому).


### Полное преуспевание
Осталось сходить на сервер и забрать желанный флаг. Есть два одинаково хороших способа:

1. Скриптом, который бы по (известным) таймингам передавал нажатия клавиш по SSH. Тут, например, подойдёт питоновая библиотека `Paramiko`.
2. Руками. Так правда можно, в чём команда разработки неоднократно убеждалась незадолго до, а также во время соревнований.

Флаг: **ugra\_you\_have\_found\_the\_correct\_vector**

---

### Внеклассное чтение: математика
Если вам правда интересно, что же такое замоделированно внутри `simulate_hit`, почитайте [исходники](bow.c).

Полёт стрелы моделировался в трёхмерном пространстве. Набежавшие параметры к ним имели вот какое отношение.

**Угол** отвечал за поворот существа `vektor` вокруг своей оси. Значения от 0 до 40 включительно экстраполировались до ±180° и превращались в радианы:
<p align="center"><img src="https://latex.codecogs.com/gif.latex?a%3d%5Cfrac%7B9%5Cpi%28ang%20-%2020%29%7D%7B180%7D"></p>
  
**Сила левой и правой руки** определяли начальную скорость по горизонтали и вертикали своим отношением:<p align="center"><img src="https://latex.codecogs.com/gif.latex?v_%7B0%7D%3d%5Cbegin%7Bpmatrix%7D%20%5Cfrac%7B13.37L%7D%7B2R&plus;1%7D%5C%5C%5B.5em%5D%20%5Cfrac%7B1.337L%7D%7B2R&plus;1%7D%5C%5C%20%5Cend%7Bpmatrix%7D"></p>
  
**Легендарность** — параметр функции, задававшей сопротивление воздуха:
<p align="center"><img src="https://latex.codecogs.com/gif.latex?k%3d%5Cexp%20%5Cleft%20%28%20log%280.75%29%20-%200.1%5Ccdot%5Cmathrm%7Blegendarity%7D%20%5Cright%20%29%20&plus;%200.25"></p>

Далее нехитрыми численными методами (спасибо Диме, Калану и Саше за подсказки!) считалось горизонтальное и вертикальное ускорение, скорость и путь — довольно школьная физика:
<p align="center"><img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5Coverrightarrow%7Ba_n%7D%20%26%3D%20-k%5Coverrightarrow%7Bv_n%7D-%5Coverrightarrow%7BG%7D%20%5C%5C%5B0.75em%5D%20%5Coverrightarrow%7Bv_%7Bn&plus;1%7D%7D%20%26%3D%20v_n%20&plus;%20%5Coverrightarrow%7Ba_n%7D%20%5Ccdot%20dt%5C%5C%5B0.75em%5D%20%5Coverrightarrow%7BS_%7Bn&plus;1%7D%7D%20%26%3D%20S_n%20&plus;%20%5Coverrightarrow%7Bv_n%7D%20%5Ccdot%20dt%5C%5C%5B0.75em%5D%20%5Cbegin%7Bpmatrix%7Dx_n%5C%5Cy_n%5C%5Cz_n%5Cend%7Bpmatrix%7D%20%26%3D%20%5Cbegin%7Bpmatrix%7D%20%5Coverrightarrow%7BS%7D%20%5Ccdot%20%5Ccos%5Ctheta%5C%5C%20%5Coverrightarrow%7BS%7D%5C%5C%20%5Coverrightarrow%7BS%7D%20%5Ccdot%20%5Csin%5Ctheta%5C%5C%20%5Cend%7Bpmatrix%7D%20%5Cend%7Balign*%7D"><br></p>

Косинус и синус — следствия поворота существа `vektor`:
<p align="center"><img src="https://k60.in/vektor-3d.png"></p>

Такие дела.
