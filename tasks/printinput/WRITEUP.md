# Print the input: Write-up

Сдав любое решение, видим, что в тестирующей системе два теста. По условию флаг лежит
в одном из них. Можно предположить, что первый тест совпадает с примером из условия,
значит флаг во втором.

Казалось бы, как можно получить какую-либо информацию о тесте. Разобравшись с тестирующей
системой, находим сторонний канал — мы видим результат тестирования. Бывают такие вердикты:

* OK — тест пройден
* WA — ответ неверен
* RE — программа завершилась некорректно
* TL — программа тратит много процессорного времени
* ML — программа тратит много памяти
* IL — программа долго не работает (ждёт лишнего ввода, спит, ...)
* и другие

Таким образом, мы за каждую посылку можем получать несколько бит информации о тесте.

Например, вот так можно проверить, действительно ли второй тест начинается с `ugra_`:

```python
s = input()
if s == "abacaba":
    print(s)        # test 1 - OK
elif s.startswith("ugra_"):
    print(s[::-1])  # test 2 - OK if starts with 'ugra_'
else:
    exit(123)       # test 2 - RE otherwise
```

Получили OK. Узнаем что-нибудь о следующем символе:

```python
import time

s = input()
if s == "abacaba":
    print(s)  # test 1 - OK
else:
    c = s[5]
    if ord(c) <= ord('f'):
        print(s[::-1])   # OK
    elif ord('g') <= ord(c) <= ord('k'):
        exit(123)  # RE
    elif ord('l') <= ord(c) <= ord('p'):
        print("wrong answer")  # WA
    elif ord('q') <= ord(c) <= ord('u'):
        time.sleep(15)  # IL
    else:
        for i in list(range(50000000)):
            if str(i) == c:
                print(".")
        print("...")  # ML
```

В результате получаем вердикт `runtime-error`, следовательно, наш символ где-то между `g` и `k`. Аналогично выясняем, какой же это конкретно символ.

Таким образом, за две попытки на символ узнаем каждый символ флага.

Флаг: **ugra\_heck**
